\documentclass[12pt]{article}

\usepackage{sbc-template}

\usepackage{graphicx,url}
\usepackage[algoruled,longend]{algorithm2e}
\usepackage[brazil]{babel}   
\usepackage[utf8]{inputenc}  
\usepackage{enumitem}
\setdescription{leftmargin=\parindent,labelindent=\parindent}
     
\sloppy

\title{Algoritmo Genéticos Paralelo: uma abordagem hierárquica}

\author{Derik Evangelista Rodrigues da Silva\inst{1}, Raphael Henrique Ferreira de Andrade\inst{1}, \\Eduardo Spinosa\inst{1}}

\address{Departamento de Informática -- Universidade Federal do Paraná
  (UFPR)\\
  Caixa Postal 19081 -- 81531-980 -- Curitiba -- PR -- Brasil
  \email{\{dersilva, rhfandrade, spinosa\}@inf.ufpr.br}
}

\begin{document} 

\maketitle

\begin{abstract}
  @TODO Abstract
\end{abstract}
     
\begin{resumo} 
  @TODO Resumo
\end{resumo}


\section{Introdução}

% O Algoritmo Genético (GA), frequentemente referenciado como \emph{algoritmos genéticos}, foi desenvolvido por John Holland na Universidade de Michigan, nos anos 70 (\cite{luke2009}).

Algoritmo Genetico (\emph{Genetic Algorithm} -- GA) são algoritmos de busca inspirados no processo de evolução e seleção natural \cite{goldberg1989} e tem tido grande sucesso em problemas de busca e de otimização, principalmente quando o espaços de busca é grande, complexo ou pouco conhecido, onde métodos de buscas convencionais (enumerativos, heurísticos, ...) não são apropriados \cite{herrera1998}. 

Um GA sequencial inicia-se gerando um conjunto de indivíduos para formar uma população inicial. Cada indivíduo representa uma possível solução do problema. Usando uma função de avaliação (chamada de função \emph{fitness}), mede-se a qualidade de cada indivíduo desta população. O cálculo do \emph{fitness} é, geralmente, o processo mais custoso de um GA \cite{paraleltax}. Seleciona-se aleatoriamente, então, um subconjunto de indivíduos desta população e neste é aplicado operadores estocásticos de seleção, mutação e cruzamento. Por fim, os indivíduos menos adaptados (ou seja, com pior \emph{fitness}) são descartados, para dar lugar a indivíduos mais bem adaptados.

% @TODO Colocar exemplos de sucesso!
Apesar do sucesso em muitas aplicações em diferentes domínios, existem, de acordo com \cite{paraleltax}, algums problemas que podem ser resolvidos com o uso de um Algoritmo Genético Paralelo (\emph{Parallel GA} -- PGA):

\begin{itemize}
  \item Para alguns tipos de problemas, o tamanho da população precisa ser muito grande, requerendo, consequentemente, uma grande quantidade de memória, podendo impossibilitar a execução eficiente em uma única máquina.
  \item O cálculo do \emph{fitness} consome muito tempo. Há registros na literatura de uma única execução consumindo mais de 1 ano de CPU.
  \item GA's sequencias podem ficar presos em regiões sub-ótimas, ficando impossibilitados de encontrar uma melhor solução. PGA's podem buscar em multiplos subespaços de busca em paralelo, e tem menos chance de ficar preso em regiões sub-ótimas.
\end{itemize}

O motivo mais importante para se estudar PGAs, ainda segundo \cite{paraleltax}, é que em muitos casos eles tem uma melhor performance do que os sequenciais, mesmo quando o paralelismo é simulado em uma máquina convencional. 

Este trabalho tem como objetivo comparar três tipos de arquiteturas de PGAs: múltiplas populações, arquitetura mestre-escravo e um híbrido de ambas, ou seja, uma combinação de múltiplas populaçõoes com mestre-escravo, aplicadas a otimização de funções. Além disso, compararemos os resultados com um GA sequencial convencional.

\section{Revisão de literatura} % (fold)
\label{sec:revisao_bibliogragica}

%Algoritmo Genetico: Origem, funcionamento, usos comuns
%AG Paralelo: concepcao, hierarquias, 

O Algoritmo Genético foi desenvolvido por John Holland na Universidade de Michigan, em 1970 \cite{holland1975}, inspirado no processo de seleção natural e evolução, e apresenta uma alternativa as técnicas clássicas de otimização, usando buscas aleatórias dirigidas para localizar soluções ótimas em espaços de buscas complexos \cite{gasurvey}. O objetivo original de Holland não era construir um algoritmo que resolvesse um problema específico, mas formalizar o estudo do fenômeno de adaptação da mesma forma que este acontece na natureza e desenvolver mecanismos de importar este comportamento em sistemas computacionais \cite{geintro1998}.

Tendo sua inspiração na biologia, alguns termos desta área são usados para descrever o GA \cite{luke2009}:
\begin{description}
	\item [Indivíduo] Solução candidata;
	\item [População] Conjunto de indivíduos;
	\item [Filhos e Pais] Um filho é uma cópia perturbada de seu pai (ambos são indivíduos);
	\item [\emph{Fitness} (Adaptabilidade)] Medida de qualidade de dada solução; 
	\item [Função de \emph{Fitness}] Função de qualidade. 
  \item [Seleção] Escolha de indivíduos, baseado em seu \emph{fitness};
  \item [Mutação] Pequena perturbação na solução;
  \item [Recombinação / Cruzamento] Grande perturbação na estrutura do indivíduo. Geralmente gera dois filhos recombinando a estrutura de seus pais.
  \item [Genoma / Genótipo] Estrutura do indivíduo;
  \item [Geração] População gerada em cada ciclo do algoritmo, que envolve as funções e transformações previamente definidas.
 \end{description}

O algoritmo apresentado em \cite{holland1975} é usualmente chamado de canônico \cite{yang2002} ou Algoritmo Genético Simples (SGA) \cite{gasurvey} e trabalha, essencialmente, com indivíduos sendo um vetor de bits, ou seja, a solução é codificada em termos de 0 e 1. Como método de seleção, o SGA usa o esquema de \emph{roleta}, onde um determinado indivíduo tem mais chance de ser escolhido para procriar dependendo de seu \emph{fitness}
 calculado.

Algumas variações foram apresentadas, como a inclusão de elitismo \cite{dejong1975}, que consiste em manter um número de indivíduos com melhor \emph{fitness} de uma geração para outra, o \emph{Steady-State Genetic Algorithm}  \cite{whitley1988}, que atualiza a população assim que os filhos são gerados, descartando-os ou inserindo-os no lugar de alguns de indivíduos piores da população e o \emph{Tree-Style Genetic Programming Pipeline}, que utiliza uma forma diferente de procriação: com 90\% de probabilidade, dois pais serão selecionados e será efetuado o cruzamento convencional e, por outro lado, com 10\% de probabilidade, será selecionado apenas um pai, que será copiado para a nova população. Existem versões, também, que se preocupam em adaptar as taxas de cruzamento e mutação em tempo de execução e abordagens híbridas, como efetuar uma busca local em cada indivíduo, usando outro algoritmo \cite{bersing1994} \cite{katare2000}.

Muitos dos algoritmos evolutivos são inerentemente paralelos \cite{hoverstad2010}, pela natureza independente de suas operações \cite{albasurvey}, e o paralelismo surge como uma alternativa para melhorar a eficiência dos GAs. 

Os algoritmos genéticos paralelos (PGA) não são apenas versões paralelas de GA sequenciais. De fato, na maioria dos casos, o todo (PGA) tem melhor performance que a soma das sub-partes que o compões \cite{albasurvey}.

A maneira com que os GAs são paralelizados depende dos seguintes elementos \cite{paraleltax}: 
\begin{itemize}
  \item Como é calculado a função \emph{fitness} e como a mutação é aplicada;
  \item Se multiplas subpopulações \emph{demes} são usadas;
  \item Se multiplas populações são usadas e como os indivíduos interagem e;
  \item Como a seleção é aplicada (globalmente ou localmente);
\end{itemize}
% @TODO REVISÃO AG PARALELO: HIERARQUIAS

Dos parâmetros acima, pode-se extrair quatro tipos principais de PGA \cite{cantu1998}: 
\begin{itemize}
  \item Mestre-escravo: globais de uma única população;
  \item Única população com paralelização \emph{fine-grained};
  \item Múltiplas populações com paralelização \emph{coarsed-grained} e;
  \item Combinação dos métodos acima
\end{itemize}
Onde \emph{fine-grained} refere-se a algoritmos paralelos com frequente comunicação entre as partes, enquanto \emph{coarse-grained} refere-se ao contrário.

O esquema mestre-escravo, usa-se uma única população e paraleliza-se os cálculos de \emph{fitness} nos processodores. Os \emph{fine-grained} PGA (FGPGA) são usados em máquinas massivamente paralelas e consistem de uma única população espacialmente estruturada e os \emph{coarsed-grained} PGA (CGPGA, também chamados de GA Distribuídos) consistem de múltiplas populações (também chamado de \emph{demes} ou \emph{ilhas}) que evoluem em paralelo e trocam indivíduos ocasionalmente (esta troca é chamada de \emph{migração}). Aos esquemas que combinam multiplas populações com mestre-escravo ou FGPGA dá se o nome de \emph{hierárquicos} (HPGA).

O primeiro PGA foi proposto em 1987 por Pettey, Leuze e Grefenstette e utilizava o esquema de multiplas populações, migrando sempre o melhor \cite{albasurvey}. \cite{tanese1989} utilizou o esquema de populações distribuídas e obteve bons resultados com migração de 20\% da população a cada 20 gerações. \cite{asparagos1989} usavam um FGPGA e aplicava \emph{hill climbing} caso não obtivesse nenhuma melhora em um determinado número de gerações. \cite{adamidis1996} utilizam múltiplas ilhas e é particularmente interessante pois cada uma das ilhas possuem suas próprias probabilidades de mutação, cruzamento e operadores especializados. \cite{wilson2010} apresentam um PGA que faz uso dos diversos núcleos das placas de vídeo de consoles de video-game, obtendo bons resultados em tempo de execução reduzido.

\cite{benitez2010} apresentam um modelo hierárquico (multiplas populações \emph{coarsed-grained} no nível mais alto e, no nível mais baixo, mestre-escravo) para o problema de desdobramento de proteínas. \cite{zeng2007} sugere um novo PGA, chamado de \emph{asynchronous heterogeneos hierarchical parallel genetic algorithm} (AHHPGA) aplicado a otimização de confiabilidade de sistemas paralelo em série, e usa um modelo \emph{coarsed-grained} como camada superior e um modelo \emph{fine-grained} na camada inferior. Este modelo proposto possui multiplas populações heterogêneas, com diferentes níveis de exploração das soluções e diferentes topologias em cada subpopulação. A migração acontece de forma assíncrona, tanto o envio quanto a recepção de novos indivíduos. Os resultados obtidos por este modelo foram ligeiramente melhores do que os obtidos por um GA tradicional, mas a faltou uma análise estatística elaborada para corroborar o modelo.
\section{Avaliação Experimental}

Esboço: Comparação entre ag tradicional, ag paralelo com multiplas populações, ag paralelo master slave e ag hibrido das duas anteriores.

Problema: funções de de jong.

Modelagem: Vetor de números reais. Cruzamento convencional. Mutação: pequena soma/subtração de número entre 0.01 e 0.05. Seleção torneio.

Análise: tabelas: tempo gasto, resultado médio em 10 execuções para cada um dos ag's, ótimo conhecido. Gráfico: fitness x geração, testes: kruskal-wallis e/ou analise de covariancia (ancova).

\bibliographystyle{sbc}
\bibliography{rel}

\end{document}
